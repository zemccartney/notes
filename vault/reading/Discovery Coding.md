---
source: https://jimmyhmiller.github.io/discovery-coding
author: Jimmy Miller
tags:
  - programming
---
>Discovery coding is a practice of understanding a problem by writing code first, rather than attempting to do some design process or thinking beforehand. This means that a discovery programmer does not always start with a plan before starting to write code; rather, they think about the situation they are in. What is the tension we are trying to solve with this new code? What are the situations that have given rise to this demand? How do these various bits of the system interact? It is only in the process of writing code and seeing the pushback the code gives that discovery programmers understand and devise a plan forward”


I’m very much a discovery writer in prose, subscribing to the what feels like certainly (tho maybe not?) apocryphal Robert Frost quote: "No tears in the writer, no tears in the reader. No surprise in the writer, no surprise in the reader." If you write only what you go into a piece planning you'll write, at least for me, you end up writing boring.


Hits home for me. In discovery, you feel out your problem space, you’re digging through your thoughts, interrogating your thoughts, crystallizing into a clear view of what you want to say. Which feels like a useful precursor to outlining? Or rather, you get the most out of both approaches by combining them, using as feedback for each other. Discovery to clarity to the formality of outlining, where, if you struggle to structure your thoughts, probably means you have some things to learn. Dare I say, discover!

  
  
> The discovery programmer, on the other hand, may be confused by the seemingly incorrectly timed questions posed by the outliner.”

  I need to work on this. Outlining and high-level thinking can be very useful for assessing impact of cross-cutting changes, especially in legacy systems. Architectural might be a better word for it. But a frequent drawback (see: driving my coworkers crazy sometimes) is bombarding people with a laundry list of hyper-specific questions. Are some of these questions useful? Sure. But oftentimes they can be premature, turning out disregardable based on what we learn from implementation. There’s a balance here, I’m off balance right now.